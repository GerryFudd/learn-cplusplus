
// 
// Multiply x array times word y in place, and add word z
// private static void destructiveMulAdd(int[] x, int y, int z) {
//     // Perform the multiplication word by word
//     long ylong = y & LONG_MASK;
//     long zlong = z & LONG_MASK;
//     int len = x.length;

//     long product = 0;
//     long carry = 0;
//     for (int i = len-1; i >= 0; i--) {
//         product = ylong * (x[i] & LONG_MASK) + carry;
//         x[i] = (int)product;
//         carry = product >>> 32;
//     }

//     // Perform the addition
//     long sum = (x[len-1] & LONG_MASK) + zlong;
//     x[len-1] = (int)sum;
//     carry = sum >>> 32;
//     for (int i = len-2; i >= 0; i--) {
//         sum = (x[i] & LONG_MASK) + carry;
//         x[i] = (int)sum;
//         carry = sum >>> 32;
//     }
// }


// /**
//  * Returns a positive BigInteger that is probably prime, with the
//  * specified bitLength. The probability that a BigInteger returned
//  * by this method is composite does not exceed 2<sup>-100</sup>.
//  *
//  * @param  bitLength bitLength of the returned BigInteger.
//  * @param  rnd source of random bits used to select candidates to be
//  *         tested for primality.
//  * @return a BigInteger of {@code bitLength} bits that is probably prime
//  * @throws ArithmeticException {@code bitLength < 2} or {@code bitLength} is too large.
//  * @see    #bitLength()
//  * @since 1.4
//  */
// public static BigInteger probablePrime(int bitLength, Random rnd) {
//     if (bitLength < 2)
//         throw new ArithmeticException("bitLength < 2");

//     return (bitLength < SMALL_PRIME_THRESHOLD ?
//             smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :
//             largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));
// }
// private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {
//     int magLen = (bitLength + 31) >>> 5;
//     int temp[] = new int[magLen];
//     int highBit = 1 << ((bitLength+31) & 0x1f);  // High bit of high int
//     int highMask = (highBit << 1) - 1;  // Bits to keep in high int

//     while (true) {
//         // Construct a candidate
//         for (int i=0; i < magLen; i++)
//             temp[i] = rnd.nextInt();
//         temp[0] = (temp[0] & highMask) | highBit;  // Ensure exact length
//         if (bitLength > 2)
//             temp[magLen-1] |= 1;  // Make odd if bitlen > 2

//         BigInteger p = new BigInteger(temp, 1);

//         // Do cheap "pre-test" if applicable
//         if (bitLength > 6) {
//             long r = p.remainder(SMALL_PRIME_PRODUCT).longValue();
//             if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
//                 (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
//                 (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))
//                 continue; // Candidate is composite; try another
//         }

//         // All candidates of bitLength 2 and 3 are prime by this point
//         if (bitLength < 4)
//             return p;

//         // Do expensive test if we survive pre-test (or it's inapplicable)
//         if (p.primeToCertainty(certainty, rnd))
//             return p;
//     }
// }

// private static final BigInteger SMALL_PRIME_PRODUCT
//                     = valueOf(3L*5*7*11*13*17*19*23*29*31*37*41);

// /**
//  * Find a random number of the specified bitLength that is probably prime.
//  * This method is more appropriate for larger bitlengths since it uses
//  * a sieve to eliminate most composites before using a more expensive
//  * test.
//  */
// private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {
//     BigInteger p;
//     p = new BigInteger(bitLength, rnd).setBit(bitLength-1);
//     p.mag[p.mag.length-1] &= 0xfffffffe;

//     // Use a sieve length likely to contain the next prime number
//     int searchLen = getPrimeSearchLen(bitLength);
//     BitSieve searchSieve = new BitSieve(p, searchLen);
//     BigInteger candidate = searchSieve.retrieve(p, certainty, rnd);

//     while ((candidate == null) || (candidate.bitLength() != bitLength)) {
//         p = p.add(BigInteger.valueOf(2*searchLen));
//         if (p.bitLength() != bitLength)
//             p = new BigInteger(bitLength, rnd).setBit(bitLength-1);
//         p.mag[p.mag.length-1] &= 0xfffffffe;
//         searchSieve = new BitSieve(p, searchLen);
//         candidate = searchSieve.retrieve(p, certainty, rnd);
//     }
//     return candidate;
// }

// /**
// * Returns the first integer greater than this {@code BigInteger} that
// * is probably prime.  The probability that the number returned by this
// * method is composite does not exceed 2<sup>-100</sup>. This method will
// * never skip over a prime when searching: if it returns {@code p}, there
// * is no prime {@code q} such that {@code this < q < p}.
// *
// * @return the first integer greater than this {@code BigInteger} that
// *         is probably prime.
// * @throws ArithmeticException {@code this < 0} or {@code this} is too large.
// * @since 1.5
// */
// public BigInteger nextProbablePrime() {
//     if (this.signum < 0)
//         throw new ArithmeticException("start < 0: " + this);

//     // Handle trivial cases
//     if ((this.signum == 0) || this.equals(ONE))
//         return TWO;

//     BigInteger result = this.add(ONE);

//     // Fastpath for small numbers
//     if (result.bitLength() < SMALL_PRIME_THRESHOLD) {

//         // Ensure an odd number
//         if (!result.testBit(0))
//             result = result.add(ONE);

//         while (true) {
//             // Do cheap "pre-test" if applicable
//             if (result.bitLength() > 6) {
//                 long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();
//                 if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
//                     (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
//                     (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {
//                     result = result.add(TWO);
//                     continue; // Candidate is composite; try another
//                 }
//             }

//             // All candidates of bitLength 2 and 3 are prime by this point
//             if (result.bitLength() < 4)
//                 return result;

//             // The expensive test
//             if (result.primeToCertainty(DEFAULT_PRIME_CERTAINTY, null))
//                 return result;

//             result = result.add(TWO);
//         }
//     }

//     // Start at previous even number
//     if (result.testBit(0))
//         result = result.subtract(ONE);

//     // Looking for the next large prime
//     int searchLen = getPrimeSearchLen(result.bitLength());

//     while (true) {
//         BitSieve searchSieve = new BitSieve(result, searchLen);
//         BigInteger candidate = searchSieve.retrieve(result,
//                                                 DEFAULT_PRIME_CERTAINTY, null);
//         if (candidate != null)
//             return candidate;
//         result = result.add(BigInteger.valueOf(2 * searchLen));
//     }
// }

// private static int getPrimeSearchLen(int bitLength) {
//     if (bitLength > PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {
//         throw new ArithmeticException("Prime search implementation restriction on bitLength");
//     }
//     return bitLength / 20 * 64;
// }

// /**
//  * Returns {@code true} if this BigInteger is probably prime,
//  * {@code false} if it's definitely composite.
//  *
//  * This method assumes bitLength > 2.
//  *
//  * @param  certainty a measure of the uncertainty that the caller is
//  *         willing to tolerate: if the call returns {@code true}
//  *         the probability that this BigInteger is prime exceeds
//  *         {@code (1 - 1/2<sup>certainty</sup>)}.  The execution time of
//  *         this method is proportional to the value of this parameter.
//  * @return {@code true} if this BigInteger is probably prime,
//  *         {@code false} if it's definitely composite.
//  */
// boolean primeToCertainty(int certainty, Random random) {
//     int rounds = 0;
//     int n = (Math.min(certainty, Integer.MAX_VALUE-1)+1)/2;

//     // The relationship between the certainty and the number of rounds
//     // we perform is given in the draft standard ANSI X9.80, "PRIME
//     // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES".
//     int sizeInBits = this.bitLength();
//     if (sizeInBits < 100) {
//         rounds = 50;
//         rounds = n < rounds ? n : rounds;
//         return passesMillerRabin(rounds, random);
//     }

//     if (sizeInBits < 256) {
//         rounds = 27;
//     } else if (sizeInBits < 512) {
//         rounds = 15;
//     } else if (sizeInBits < 768) {
//         rounds = 8;
//     } else if (sizeInBits < 1024) {
//         rounds = 4;
//     } else {
//         rounds = 2;
//     }
//     rounds = n < rounds ? n : rounds;

//     return passesMillerRabin(rounds, random) && passesLucasLehmer();
// }

// /**
//  * Returns true iff this BigInteger is a Lucas-Lehmer probable prime.
//  *
//  * The following assumptions are made:
//  * This BigInteger is a positive, odd number.
//  */
// private boolean passesLucasLehmer() {
//     BigInteger thisPlusOne = this.add(ONE);

//     // Step 1
//     int d = 5;
//     while (jacobiSymbol(d, this) != -1) {
//         // 5, -7, 9, -11, ...
//         d = (d < 0) ? Math.abs(d)+2 : -(d+2);
//     }

//     // Step 2
//     BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);

//     // Step 3
//     return u.mod(this).equals(ZERO);
// }

// /**
//  * Computes Jacobi(p,n).
//  * Assumes n positive, odd, n>=3.
//  */
// private static int jacobiSymbol(int p, BigInteger n) {
//     if (p == 0)
//         return 0;

//     // Algorithm and comments adapted from Colin Plumb's C library.
//     int j = 1;
//     int u = n.mag[n.mag.length-1];

//     // Make p positive
//     if (p < 0) {
//         p = -p;
//         int n8 = u & 7;
//         if ((n8 == 3) || (n8 == 7))
//             j = -j; // 3 (011) or 7 (111) mod 8
//     }

//     // Get rid of factors of 2 in p
//     while ((p & 3) == 0)
//         p >>= 2;
//     if ((p & 1) == 0) {
//         p >>= 1;
//         if (((u ^ (u>>1)) & 2) != 0)
//             j = -j; // 3 (011) or 5 (101) mod 8
//     }
//     if (p == 1)
//         return j;
//     // Then, apply quadratic reciprocity
//     if ((p & u & 2) != 0)   // p = u = 3 (mod 4)?
//         j = -j;
//     // And reduce u mod p
//     u = n.mod(BigInteger.valueOf(p)).intValue();

//     // Now compute Jacobi(u,p), u < p
//     while (u != 0) {
//         while ((u & 3) == 0)
//             u >>= 2;
//         if ((u & 1) == 0) {
//             u >>= 1;
//             if (((p ^ (p>>1)) & 2) != 0)
//                 j = -j;     // 3 (011) or 5 (101) mod 8
//         }
//         if (u == 1)
//             return j;
//         // Now both u and p are odd, so use quadratic reciprocity
//         assert (u < p);
//         int t = u; u = p; p = t;
//         if ((u & p & 2) != 0) // u = p = 3 (mod 4)?
//             j = -j;
//         // Now u >= p, so it can be reduced
//         u %= p;
//     }
//     return 0;
// }

// private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {
//     BigInteger d = BigInteger.valueOf(z);
//     BigInteger u = ONE; BigInteger u2;
//     BigInteger v = ONE; BigInteger v2;

//     for (int i=k.bitLength()-2; i >= 0; i--) {
//         u2 = u.multiply(v).mod(n);

//         v2 = v.square().add(d.multiply(u.square())).mod(n);
//         if (v2.testBit(0))
//             v2 = v2.subtract(n);

//         v2 = v2.shiftRight(1);

//         u = u2; v = v2;
//         if (k.testBit(i)) {
//             u2 = u.add(v).mod(n);
//             if (u2.testBit(0))
//                 u2 = u2.subtract(n);

//             u2 = u2.shiftRight(1);
//             v2 = v.add(d.multiply(u)).mod(n);
//             if (v2.testBit(0))
//                 v2 = v2.subtract(n);
//             v2 = v2.shiftRight(1);

//             u = u2; v = v2;
//         }
//     }
//     return u;
// }

// /**
//  * Returns true iff this BigInteger passes the specified number of
//  * Miller-Rabin tests. This test is taken from the DSA spec (NIST FIPS
//  * 186-2).
//  *
//  * The following assumptions are made:
//  * This BigInteger is a positive, odd number greater than 2.
//  * iterations<=50.
//  */
// private boolean passesMillerRabin(int iterations, Random rnd) {
//     // Find a and m such that m is odd and this == 1 + 2**a * m
//     BigInteger thisMinusOne = this.subtract(ONE);
//     BigInteger m = thisMinusOne;
//     int a = m.getLowestSetBit();
//     m = m.shiftRight(a);

//     // Do the tests
//     if (rnd == null) {
//         rnd = ThreadLocalRandom.current();
//     }
//     for (int i=0; i < iterations; i++) {
//         // Generate a uniform random on (1, this)
//         BigInteger b;
//         do {
//             b = new BigInteger(this.bitLength(), rnd);
//         } while (b.compareTo(ONE) <= 0 || b.compareTo(this) >= 0);

//         int j = 0;
//         BigInteger z = b.modPow(m, this);
//         while (!((j == 0 && z.equals(ONE)) || z.equals(thisMinusOne))) {
//             if (j > 0 && z.equals(ONE) || ++j == a)
//                 return false;
//             z = z.modPow(TWO, this);
//         }
//     }
//     return true;
// }


// /**
//  * The cache of powers of each radix.  This allows us to not have to
//  * recalculate powers of radix^(2^n) more than once.  This speeds
//  * Schoenhage recursive base conversion significantly.
//  */
// private static volatile BigInteger[][] powerCache;

// /** The cache of logarithms of radices for base conversion. */
// private static final double[] logCache;

// /** The natural log of 2.  This is used in computing cache indices. */
// private static final double LOG_TWO = Math.log(2.0);

// static {
//     assert 0 < KARATSUBA_THRESHOLD
//         && KARATSUBA_THRESHOLD < TOOM_COOK_THRESHOLD
//         && TOOM_COOK_THRESHOLD < Integer.MAX_VALUE
//         && 0 < KARATSUBA_SQUARE_THRESHOLD
//         && KARATSUBA_SQUARE_THRESHOLD < TOOM_COOK_SQUARE_THRESHOLD
//         && TOOM_COOK_SQUARE_THRESHOLD < Integer.MAX_VALUE :
//         "Algorithm thresholds are inconsistent";

//     for (int i = 1; i <= MAX_CONSTANT; i++) {
//         int[] magnitude = new int[1];
//         magnitude[0] = i;
//         posConst[i] = new BigInteger(magnitude,  1);
//         negConst[i] = new BigInteger(magnitude, -1);
//     }

//     /*
//         * Initialize the cache of radix^(2^x) values used for base conversion
//         * with just the very first value.  Additional values will be created
//         * on demand.
//         */
//     powerCache = new BigInteger[Character.MAX_RADIX+1][];
//     logCache = new double[Character.MAX_RADIX+1];

//     for (int i=Character.MIN_RADIX; i <= Character.MAX_RADIX; i++) {
//         powerCache[i] = new BigInteger[] { BigInteger.valueOf(i) };
//         logCache[i] = Math.log(i);
//     }
// }



// // Arithmetic Operations

// /**
//  * Returns a BigInteger whose value is {@code (this + val)}.
//  *
//  * @param  val value to be added to this BigInteger.
//  * @return {@code this + val}
//  */
// public BigInteger add(BigInteger val) {
//     if (val.signum == 0)
//         return this;
//     if (signum == 0)
//         return val;
//     if (val.signum == signum)
//         return new BigInteger(add(mag, val.mag), signum);

//     int cmp = compareMagnitude(val);
//     if (cmp == 0)
//         return ZERO;
//     int[] resultMag = (cmp > 0 ? subtract(mag, val.mag)
//                         : subtract(val.mag, mag));
//     resultMag = trustedStripLeadingZeroInts(resultMag);

//     return new BigInteger(resultMag, cmp == signum ? 1 : -1);
// }

// /**
//  * Adds the contents of the int array x and long value val. This
//  * method allocates a new int array to hold the answer and returns
//  * a reference to that array.  Assumes x.length &gt; 0 and val is
//  * non-negative
//  */
// private static int[] add(int[] x, long val) {
//     int[] y;
//     long sum = 0;
//     int xIndex = x.length;
//     int[] result;
//     int highWord = (int)(val >>> 32);
//     if (highWord == 0) {
//         result = new int[xIndex];
//         sum = (x[--xIndex] & LONG_MASK) + val;
//         result[xIndex] = (int)sum;
//     } else {
//         if (xIndex == 1) {
//             result = new int[2];
//             sum = val  + (x[0] & LONG_MASK);
//             result[1] = (int)sum;
//             result[0] = (int)(sum >>> 32);
//             return result;
//         } else {
//             result = new int[xIndex];
//             sum = (x[--xIndex] & LONG_MASK) + (val & LONG_MASK);
//             result[xIndex] = (int)sum;
//             sum = (x[--xIndex] & LONG_MASK) + (highWord & LONG_MASK) + (sum >>> 32);
//             result[xIndex] = (int)sum;
//         }
//     }
//     // Copy remainder of longer number while carry propagation is required
//     boolean carry = (sum >>> 32 != 0);
//     while (xIndex > 0 && carry)
//         carry = ((result[--xIndex] = x[xIndex] + 1) == 0);
//     // Copy remainder of longer number
//     while (xIndex > 0)
//         result[--xIndex] = x[xIndex];
//     // Grow result if necessary
//     if (carry) {
//         int bigger[] = new int[result.length + 1];
//         System.arraycopy(result, 0, bigger, 1, result.length);
//         bigger[0] = 0x01;
//         return bigger;
//     }
//     return result;
// }

// /**
//  * Adds the contents of the int arrays x and y. This method allocates
//  * a new int array to hold the answer and returns a reference to that
//  * array.
//  */
// private static int[] add(int[] x, int[] y) {
//     // If x is shorter, swap the two arrays
//     if (x.length < y.length) {
//         int[] tmp = x;
//         x = y;
//         y = tmp;
//     }

//     int xIndex = x.length;
//     int yIndex = y.length;
//     int result[] = new int[xIndex];
//     long sum = 0;
//     if (yIndex == 1) {
//         sum = (x[--xIndex] & LONG_MASK) + (y[0] & LONG_MASK) ;
//         result[xIndex] = (int)sum;
//     } else {
//         // Add common parts of both numbers
//         while (yIndex > 0) {
//             sum = (x[--xIndex] & LONG_MASK) +
//                     (y[--yIndex] & LONG_MASK) + (sum >>> 32);
//             result[xIndex] = (int)sum;
//         }
//     }
//     // Copy remainder of longer number while carry propagation is required
//     boolean carry = (sum >>> 32 != 0);
//     while (xIndex > 0 && carry)
//         carry = ((result[--xIndex] = x[xIndex] + 1) == 0);

//     // Copy remainder of longer number
//     while (xIndex > 0)
//         result[--xIndex] = x[xIndex];

//     // Grow result if necessary
//     if (carry) {
//         int bigger[] = new int[result.length + 1];
//         System.arraycopy(result, 0, bigger, 1, result.length);
//         bigger[0] = 0x01;
//         return bigger;
//     }
//     return result;
// }

// private static int[] subtract(long val, int[] little) {
//     int highWord = (int)(val >>> 32);
//     if (highWord == 0) {
//         int result[] = new int[1];
//         result[0] = (int)(val - (little[0] & LONG_MASK));
//         return result;
//     } else {
//         int result[] = new int[2];
//         if (little.length == 1) {
//             long difference = ((int)val & LONG_MASK) - (little[0] & LONG_MASK);
//             result[1] = (int)difference;
//             // Subtract remainder of longer number while borrow propagates
//             boolean borrow = (difference >> 32 != 0);
//             if (borrow) {
//                 result[0] = highWord - 1;
//             } else {        // Copy remainder of longer number
//                 result[0] = highWord;
//             }
//             return result;
//         } else { // little.length == 2
//             long difference = ((int)val & LONG_MASK) - (little[1] & LONG_MASK);
//             result[1] = (int)difference;
//             difference = (highWord & LONG_MASK) - (little[0] & LONG_MASK) + (difference >> 32);
//             result[0] = (int)difference;
//             return result;
//         }
//     }
// }

// /**
//  * Subtracts the contents of the second argument (val) from the
//  * first (big).  The first int array (big) must represent a larger number
//  * than the second.  This method allocates the space necessary to hold the
//  * answer.
//  * assumes val &gt;= 0
//  */
// private static int[] subtract(int[] big, long val) {
//     int highWord = (int)(val >>> 32);
//     int bigIndex = big.length;
//     int result[] = new int[bigIndex];
//     long difference = 0;

//     if (highWord == 0) {
//         difference = (big[--bigIndex] & LONG_MASK) - val;
//         result[bigIndex] = (int)difference;
//     } else {
//         difference = (big[--bigIndex] & LONG_MASK) - (val & LONG_MASK);
//         result[bigIndex] = (int)difference;
//         difference = (big[--bigIndex] & LONG_MASK) - (highWord & LONG_MASK) + (difference >> 32);
//         result[bigIndex] = (int)difference;
//     }

//     // Subtract remainder of longer number while borrow propagates
//     boolean borrow = (difference >> 32 != 0);
//     while (bigIndex > 0 && borrow)
//         borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);

//     // Copy remainder of longer number
//     while (bigIndex > 0)
//         result[--bigIndex] = big[bigIndex];

//     return result;
// }

// /**
//  * Returns a BigInteger whose value is {@code (this - val)}.
//  *
//  * @param  val value to be subtracted from this BigInteger.
//  * @return {@code this - val}
//  */
// public BigInteger subtract(BigInteger val) {
//     if (val.signum == 0)
//         return this;
//     if (signum == 0)
//         return val.negate();
//     if (val.signum != signum)
//         return new BigInteger(add(mag, val.mag), signum);

//     int cmp = compareMagnitude(val);
//     if (cmp == 0)
//         return ZERO;
//     int[] resultMag = (cmp > 0 ? subtract(mag, val.mag)
//                         : subtract(val.mag, mag));
//     resultMag = trustedStripLeadingZeroInts(resultMag);
//     return new BigInteger(resultMag, cmp == signum ? 1 : -1);
// }

// /**
//  * Subtracts the contents of the second int arrays (little) from the
//  * first (big).  The first int array (big) must represent a larger number
//  * than the second.  This method allocates the space necessary to hold the
//  * answer.
//  */
// private static int[] subtract(int[] big, int[] little) {
//     int bigIndex = big.length;
//     int result[] = new int[bigIndex];
//     int littleIndex = little.length;
//     long difference = 0;

//     // Subtract common parts of both numbers
//     while (littleIndex > 0) {
//         difference = (big[--bigIndex] & LONG_MASK) -
//                         (little[--littleIndex] & LONG_MASK) +
//                         (difference >> 32);
//         result[bigIndex] = (int)difference;
//     }

//     // Subtract remainder of longer number while borrow propagates
//     boolean borrow = (difference >> 32 != 0);
//     while (bigIndex > 0 && borrow)
//         borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);

//     // Copy remainder of longer number
//     while (bigIndex > 0)
//         result[--bigIndex] = big[bigIndex];

//     return result;
// }

// /**
//  * Returns a BigInteger whose value is {@code (this * val)}.
//  *
//  * @implNote An implementation may offer better algorithmic
//  * performance when {@code val == this}.
//  *
//  * @param  val value to be multiplied by this BigInteger.
//  * @return {@code this * val}
//  */
// public BigInteger multiply(BigInteger val) {
//     return multiply(val, false);
// }

// /**
//  * Returns a BigInteger whose value is {@code (this * val)}.  If
//  * the invocation is recursive certain overflow checks are skipped.
//  *
//  * @param  val value to be multiplied by this BigInteger.
//  * @param  isRecursion whether this is a recursive invocation
//  * @return {@code this * val}
//  */
// private BigInteger multiply(BigInteger val, boolean isRecursion) {
//     if (val.signum == 0 || signum == 0)
//         return ZERO;

//     int xlen = mag.length;

//     if (val == this && xlen > MULTIPLY_SQUARE_THRESHOLD) {
//         return square();
//     }

//     int ylen = val.mag.length;

//     if ((xlen < KARATSUBA_THRESHOLD) || (ylen < KARATSUBA_THRESHOLD)) {
//         int resultSign = signum == val.signum ? 1 : -1;
//         if (val.mag.length == 1) {
//             return multiplyByInt(mag,val.mag[0], resultSign);
//         }
//         if (mag.length == 1) {
//             return multiplyByInt(val.mag,mag[0], resultSign);
//         }
//         int[] result = multiplyToLen(mag, xlen,
//                                         val.mag, ylen, null);
//         result = trustedStripLeadingZeroInts(result);
//         return new BigInteger(result, resultSign);
//     } else {
//         if ((xlen < TOOM_COOK_THRESHOLD) && (ylen < TOOM_COOK_THRESHOLD)) {
//             return multiplyKaratsuba(this, val);
//         } else {
//             //
//             // In "Hacker's Delight" section 2-13, p.33, it is explained
//             // that if x and y are unsigned 32-bit quantities and m and n
//             // are their respective numbers of leading zeros within 32 bits,
//             // then the number of leading zeros within their product as a
//             // 64-bit unsigned quantity is either m + n or m + n + 1. If
//             // their product is not to overflow, it cannot exceed 32 bits,
//             // and so the number of leading zeros of the product within 64
//             // bits must be at least 32, i.e., the leftmost set bit is at
//             // zero-relative position 31 or less.
//             //
//             // From the above there are three cases:
//             //
//             //     m + n    leftmost set bit    condition
//             //     -----    ----------------    ---------
//             //     >= 32    x <= 64 - 32 = 32   no overflow
//             //     == 31    x >= 64 - 32 = 32   possible overflow
//             //     <= 30    x >= 64 - 31 = 33   definite overflow
//             //
//             // The "possible overflow" condition cannot be detected by
//             // examning data lengths alone and requires further calculation.
//             //
//             // By analogy, if 'this' and 'val' have m and n as their
//             // respective numbers of leading zeros within 32*MAX_MAG_LENGTH
//             // bits, then:
//             //
//             //     m + n >= 32*MAX_MAG_LENGTH        no overflow
//             //     m + n == 32*MAX_MAG_LENGTH - 1    possible overflow
//             //     m + n <= 32*MAX_MAG_LENGTH - 2    definite overflow
//             //
//             // Note however that if the number of ints in the result
//             // were to be MAX_MAG_LENGTH and mag[0] < 0, then there would
//             // be overflow. As a result the leftmost bit (of mag[0]) cannot
//             // be used and the constraints must be adjusted by one bit to:
//             //
//             //     m + n >  32*MAX_MAG_LENGTH        no overflow
//             //     m + n == 32*MAX_MAG_LENGTH        possible overflow
//             //     m + n <  32*MAX_MAG_LENGTH        definite overflow
//             //
//             // The foregoing leading zero-based discussion is for clarity
//             // only. The actual calculations use the estimated bit length
//             // of the product as this is more natural to the internal
//             // array representation of the magnitude which has no leading
//             // zero elements.
//             //
//             if (!isRecursion) {
//                 // The bitLength() instance method is not used here as we
//                 // are only considering the magnitudes as non-negative. The
//                 // Toom-Cook multiplication algorithm determines the sign
//                 // at its end from the two signum values.
//                 if ((long)bitLength(mag, mag.length) +
//                     (long)bitLength(val.mag, val.mag.length) >
//                     32L*MAX_MAG_LENGTH) {
//                     reportOverflow();
//                 }
//             }

//             return multiplyToomCook3(this, val);
//         }
//     }
// }

// private static BigInteger multiplyByInt(int[] x, int y, int sign) {
//     if (Integer.bitCount(y) == 1) {
//         return new BigInteger(shiftLeft(x,Integer.numberOfTrailingZeros(y)), sign);
//     }
//     int xlen = x.length;
//     int[] rmag =  new int[xlen + 1];
//     long carry = 0;
//     long yl = y & LONG_MASK;
//     int rstart = rmag.length - 1;
//     for (int i = xlen - 1; i >= 0; i--) {
//         long product = (x[i] & LONG_MASK) * yl + carry;
//         rmag[rstart--] = (int)product;
//         carry = product >>> 32;
//     }
//     if (carry == 0L) {
//         rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);
//     } else {
//         rmag[rstart] = (int)carry;
//     }
//     return new BigInteger(rmag, sign);
// }

// /**
//  * Package private methods used by BigDecimal code to multiply a BigInteger
//  * with a long. Assumes v is not equal to INFLATED.
//  */
// BigInteger multiply(long v) {
//     if (v == 0 || signum == 0)
//         return ZERO;
//     if (v == BigDecimal.INFLATED)
//         return multiply(BigInteger.valueOf(v));
//     int rsign = (v > 0 ? signum : -signum);
//     if (v < 0)
//         v = -v;
//     long dh = v >>> 32;      // higher order bits
//     long dl = v & LONG_MASK; // lower order bits

//     int xlen = mag.length;
//     int[] value = mag;
//     int[] rmag = (dh == 0L) ? (new int[xlen + 1]) : (new int[xlen + 2]);
//     long carry = 0;
//     int rstart = rmag.length - 1;
//     for (int i = xlen - 1; i >= 0; i--) {
//         long product = (value[i] & LONG_MASK) * dl + carry;
//         rmag[rstart--] = (int)product;
//         carry = product >>> 32;
//     }
//     rmag[rstart] = (int)carry;
//     if (dh != 0L) {
//         carry = 0;
//         rstart = rmag.length - 2;
//         for (int i = xlen - 1; i >= 0; i--) {
//             long product = (value[i] & LONG_MASK) * dh +
//                 (rmag[rstart] & LONG_MASK) + carry;
//             rmag[rstart--] = (int)product;
//             carry = product >>> 32;
//         }
//         rmag[0] = (int)carry;
//     }
//     if (carry == 0L)
//         rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);
//     return new BigInteger(rmag, rsign);
// }

// /**
//  * Multiplies int arrays x and y to the specified lengths and places
//  * the result into z. There will be no leading zeros in the resultant array.
//  */
// private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
//     multiplyToLenCheck(x, xlen);
//     multiplyToLenCheck(y, ylen);
//     return implMultiplyToLen(x, xlen, y, ylen, z);
// }

// @HotSpotIntrinsicCandidate
// private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
//     int xstart = xlen - 1;
//     int ystart = ylen - 1;

//     if (z == null || z.length < (xlen+ ylen))
//             z = new int[xlen+ylen];

//     long carry = 0;
//     for (int j=ystart, k=ystart+1+xstart; j >= 0; j--, k--) {
//         long product = (y[j] & LONG_MASK) *
//                         (x[xstart] & LONG_MASK) + carry;
//         z[k] = (int)product;
//         carry = product >>> 32;
//     }
//     z[xstart] = (int)carry;

//     for (int i = xstart-1; i >= 0; i--) {
//         carry = 0;
//         for (int j=ystart, k=ystart+1+i; j >= 0; j--, k--) {
//             long product = (y[j] & LONG_MASK) *
//                             (x[i] & LONG_MASK) +
//                             (z[k] & LONG_MASK) + carry;
//             z[k] = (int)product;
//             carry = product >>> 32;
//         }
//         z[i] = (int)carry;
//     }
//     return z;
// }

// private static void multiplyToLenCheck(int[] array, int length) {
//     if (length <= 0) {
//         return;  // not an error because multiplyToLen won't execute if len <= 0
//     }

//     Objects.requireNonNull(array);

//     if (length > array.length) {
//         throw new ArrayIndexOutOfBoundsException(length - 1);
//     }
// }

// /**
//  * Multiplies two BigIntegers using the Karatsuba multiplication
//  * algorithm.  This is a recursive divide-and-conquer algorithm which is
//  * more efficient for large numbers than what is commonly called the
//  * "grade-school" algorithm used in multiplyToLen.  If the numbers to be
//  * multiplied have length n, the "grade-school" algorithm has an
//  * asymptotic complexity of O(n^2).  In contrast, the Karatsuba algorithm
//  * has complexity of O(n^(log2(3))), or O(n^1.585).  It achieves this
//  * increased performance by doing 3 multiplies instead of 4 when
//  * evaluating the product.  As it has some overhead, should be used when
//  * both numbers are larger than a certain threshold (found
//  * experimentally).
//  *
//  * See:  http://en.wikipedia.org/wiki/Karatsuba_algorithm
//  */
// private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {
//     int xlen = x.mag.length;
//     int ylen = y.mag.length;

//     // The number of ints in each half of the number.
//     int half = (Math.max(xlen, ylen)+1) / 2;

//     // xl and yl are the lower halves of x and y respectively,
//     // xh and yh are the upper halves.
//     BigInteger xl = x.getLower(half);
//     BigInteger xh = x.getUpper(half);
//     BigInteger yl = y.getLower(half);
//     BigInteger yh = y.getUpper(half);

//     BigInteger p1 = xh.multiply(yh);  // p1 = xh*yh
//     BigInteger p2 = xl.multiply(yl);  // p2 = xl*yl

//     // p3=(xh+xl)*(yh+yl)
//     BigInteger p3 = xh.add(xl).multiply(yh.add(yl));

//     // result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2
//     BigInteger result = p1.shiftLeft(32*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32*half).add(p2);

//     if (x.signum != y.signum) {
//         return result.negate();
//     } else {
//         return result;
//     }
// }

// /**
//  * Multiplies two BigIntegers using a 3-way Toom-Cook multiplication
//  * algorithm.  This is a recursive divide-and-conquer algorithm which is
//  * more efficient for large numbers than what is commonly called the
//  * "grade-school" algorithm used in multiplyToLen.  If the numbers to be
//  * multiplied have length n, the "grade-school" algorithm has an
//  * asymptotic complexity of O(n^2).  In contrast, 3-way Toom-Cook has a
//  * complexity of about O(n^1.465).  It achieves this increased asymptotic
//  * performance by breaking each number into three parts and by doing 5
//  * multiplies instead of 9 when evaluating the product.  Due to overhead
//  * (additions, shifts, and one division) in the Toom-Cook algorithm, it
//  * should only be used when both numbers are larger than a certain
//  * threshold (found experimentally).  This threshold is generally larger
//  * than that for Karatsuba multiplication, so this algorithm is generally
//  * only used when numbers become significantly larger.
//  *
//  * The algorithm used is the "optimal" 3-way Toom-Cook algorithm outlined
//  * by Marco Bodrato.
//  *
//  *  See: http://bodrato.it/toom-cook/
//  *       http://bodrato.it/papers/#WAIFI2007
//  *
//  * "Towards Optimal Toom-Cook Multiplication for Univariate and
//  * Multivariate Polynomials in Characteristic 2 and 0." by Marco BODRATO;
//  * In C.Carlet and B.Sunar, Eds., "WAIFI'07 proceedings", p. 116-133,
//  * LNCS #4547. Springer, Madrid, Spain, June 21-22, 2007.
//  *
//  */
// private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {
//     int alen = a.mag.length;
//     int blen = b.mag.length;

//     int largest = Math.max(alen, blen);

//     // k is the size (in ints) of the lower-order slices.
//     int k = (largest+2)/3;   // Equal to ceil(largest/3)

//     // r is the size (in ints) of the highest-order slice.
//     int r = largest - 2*k;

//     // Obtain slices of the numbers. a2 and b2 are the most significant
//     // bits of the numbers a and b, and a0 and b0 the least significant.
//     BigInteger a0, a1, a2, b0, b1, b2;
//     a2 = a.getToomSlice(k, r, 0, largest);
//     a1 = a.getToomSlice(k, r, 1, largest);
//     a0 = a.getToomSlice(k, r, 2, largest);
//     b2 = b.getToomSlice(k, r, 0, largest);
//     b1 = b.getToomSlice(k, r, 1, largest);
//     b0 = b.getToomSlice(k, r, 2, largest);

//     BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1;

//     v0 = a0.multiply(b0, true);
//     da1 = a2.add(a0);
//     db1 = b2.add(b0);
//     vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);
//     da1 = da1.add(a1);
//     db1 = db1.add(b1);
//     v1 = da1.multiply(db1, true);
//     v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(
//             db1.add(b2).shiftLeft(1).subtract(b0), true);
//     vinf = a2.multiply(b2, true);

//     // The algorithm requires two divisions by 2 and one by 3.
//     // All divisions are known to be exact, that is, they do not produce
//     // remainders, and all results are positive.  The divisions by 2 are
//     // implemented as right shifts which are relatively efficient, leaving
//     // only an exact division by 3, which is done by a specialized
//     // linear-time algorithm.
//     t2 = v2.subtract(vm1).exactDivideBy3();
//     tm1 = v1.subtract(vm1).shiftRight(1);
//     t1 = v1.subtract(v0);
//     t2 = t2.subtract(t1).shiftRight(1);
//     t1 = t1.subtract(tm1).subtract(vinf);
//     t2 = t2.subtract(vinf.shiftLeft(1));
//     tm1 = tm1.subtract(t2);

//     // Number of bits to shift left.
//     int ss = k*32;

//     BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);

//     if (a.signum != b.signum) {
//         return result.negate();
//     } else {
//         return result;
//     }
// }


// /**
//  * Returns a slice of a BigInteger for use in Toom-Cook multiplication.
//  *
//  * @param lowerSize The size of the lower-order bit slices.
//  * @param upperSize The size of the higher-order bit slices.
//  * @param slice The index of which slice is requested, which must be a
//  * number from 0 to size-1. Slice 0 is the highest-order bits, and slice
//  * size-1 are the lowest-order bits. Slice 0 may be of different size than
//  * the other slices.
//  * @param fullsize The size of the larger integer array, used to align
//  * slices to the appropriate position when multiplying different-sized
//  * numbers.
//  */
// private BigInteger getToomSlice(int lowerSize, int upperSize, int slice,
//                                 int fullsize) {
//     int start, end, sliceSize, len, offset;

//     len = mag.length;
//     offset = fullsize - len;

//     if (slice == 0) {
//         start = 0 - offset;
//         end = upperSize - 1 - offset;
//     } else {
//         start = upperSize + (slice-1)*lowerSize - offset;
//         end = start + lowerSize - 1;
//     }

//     if (start < 0) {
//         start = 0;
//     }
//     if (end < 0) {
//         return ZERO;
//     }

//     sliceSize = (end-start) + 1;

//     if (sliceSize <= 0) {
//         return ZERO;
//     }

//     // While performing Toom-Cook, all slices are positive and
//     // the sign is adjusted when the final number is composed.
//     if (start == 0 && sliceSize >= len) {
//         return this.abs();
//     }

//     int intSlice[] = new int[sliceSize];
//     System.arraycopy(mag, start, intSlice, 0, sliceSize);

//     return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);
// }

// /**
//  * Does an exact division (that is, the remainder is known to be zero)
//  * of the specified number by 3.  This is used in Toom-Cook
//  * multiplication.  This is an efficient algorithm that runs in linear
//  * time.  If the argument is not exactly divisible by 3, results are
//  * undefined.  Note that this is expected to be called with positive
//  * arguments only.
//  */
// private BigInteger exactDivideBy3() {
//     int len = mag.length;
//     int[] result = new int[len];
//     long x, w, q, borrow;
//     borrow = 0L;
//     for (int i=len-1; i >= 0; i--) {
//         x = (mag[i] & LONG_MASK);
//         w = x - borrow;
//         if (borrow > x) {      // Did we make the number go negative?
//             borrow = 1L;
//         } else {
//             borrow = 0L;
//         }

//         // 0xAAAAAAAB is the modular inverse of 3 (mod 2^32).  Thus,
//         // the effect of this is to divide by 3 (mod 2^32).
//         // This is much faster than division on most architectures.
//         q = (w * 0xAAAAAAABL) & LONG_MASK;
//         result[i] = (int) q;

//         // Now check the borrow. The second check can of course be
//         // eliminated if the first fails.
//         if (q >= 0x55555556L) {
//             borrow++;
//             if (q >= 0xAAAAAAABL)
//                 borrow++;
//         }
//     }
//     result = trustedStripLeadingZeroInts(result);
//     return new BigInteger(result, signum);
// }

// /**
//  * Returns a new BigInteger representing n lower ints of the number.
//  * This is used by Karatsuba multiplication and Karatsuba squaring.
//  */
// private BigInteger getLower(int n) {
//     int len = mag.length;

//     if (len <= n) {
//         return abs();
//     }

//     int lowerInts[] = new int[n];
//     System.arraycopy(mag, len-n, lowerInts, 0, n);

//     return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);
// }

// /**
//  * Returns a new BigInteger representing mag.length-n upper
//  * ints of the number.  This is used by Karatsuba multiplication and
//  * Karatsuba squaring.
//  */
// private BigInteger getUpper(int n) {
//     int len = mag.length;

//     if (len <= n) {
//         return ZERO;
//     }

//     int upperLen = len - n;
//     int upperInts[] = new int[upperLen];
//     System.arraycopy(mag, 0, upperInts, 0, upperLen);

//     return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);
// }

// // Division

// /**
//  * Returns a BigInteger whose value is {@code (this / val)}.
//  *
//  * @param  val value by which this BigInteger is to be divided.
//  * @return {@code this / val}
//  * @throws ArithmeticException if {@code val} is zero.
//  */
// public BigInteger divide(BigInteger val) {
//     if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||
//             mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {
//         return divideKnuth(val);
//     } else {
//         return divideBurnikelZiegler(val);
//     }
// }

// /**
//  * Returns a BigInteger whose value is {@code (this / val)} using an O(n^2) algorithm from Knuth.
//  *
//  * @param  val value by which this BigInteger is to be divided.
//  * @return {@code this / val}
//  * @throws ArithmeticException if {@code val} is zero.
//  * @see MutableBigInteger#divideKnuth(MutableBigInteger, MutableBigInteger, boolean)
//  */
// private BigInteger divideKnuth(BigInteger val) {
//     MutableBigInteger q = new MutableBigInteger(),
//                         a = new MutableBigInteger(this.mag),
//                         b = new MutableBigInteger(val.mag);

//     a.divideKnuth(b, q, false);
//     return q.toBigInteger(this.signum * val.signum);
// }

// /**
//  * Returns an array of two BigIntegers containing {@code (this / val)}
//  * followed by {@code (this % val)}.
//  *
//  * @param  val value by which this BigInteger is to be divided, and the
//  *         remainder computed.
//  * @return an array of two BigIntegers: the quotient {@code (this / val)}
//  *         is the initial element, and the remainder {@code (this % val)}
//  *         is the final element.
//  * @throws ArithmeticException if {@code val} is zero.
//  */
// public BigInteger[] divideAndRemainder(BigInteger val) {
//     if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||
//             mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {
//         return divideAndRemainderKnuth(val);
//     } else {
//         return divideAndRemainderBurnikelZiegler(val);
//     }
// }

// /** Long division */
// private BigInteger[] divideAndRemainderKnuth(BigInteger val) {
//     BigInteger[] result = new BigInteger[2];
//     MutableBigInteger q = new MutableBigInteger(),
//                         a = new MutableBigInteger(this.mag),
//                         b = new MutableBigInteger(val.mag);
//     MutableBigInteger r = a.divideKnuth(b, q);
//     result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);
//     result[1] = r.toBigInteger(this.signum);
//     return result;
// }

// /**
//  * Returns a BigInteger whose value is {@code (this % val)}.
//  *
//  * @param  val value by which this BigInteger is to be divided, and the
//  *         remainder computed.
//  * @return {@code this % val}
//  * @throws ArithmeticException if {@code val} is zero.
//  */
// public BigInteger remainder(BigInteger val) {
//     if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||
//             mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {
//         return remainderKnuth(val);
//     } else {
//         return remainderBurnikelZiegler(val);
//     }
// }

// /** Long division */
// private BigInteger remainderKnuth(BigInteger val) {
//     MutableBigInteger q = new MutableBigInteger(),
//                         a = new MutableBigInteger(this.mag),
//                         b = new MutableBigInteger(val.mag);

//     return a.divideKnuth(b, q).toBigInteger(this.signum);
// }

// /**
//  * Calculates {@code this / val} using the Burnikel-Ziegler algorithm.
//  * @param  val the divisor
//  * @return {@code this / val}
//  */
// private BigInteger divideBurnikelZiegler(BigInteger val) {
//     return divideAndRemainderBurnikelZiegler(val)[0];
// }

// /**
//  * Calculates {@code this % val} using the Burnikel-Ziegler algorithm.
//  * @param val the divisor
//  * @return {@code this % val}
//  */
// private BigInteger remainderBurnikelZiegler(BigInteger val) {
//     return divideAndRemainderBurnikelZiegler(val)[1];
// }

// /**
//  * Computes {@code this / val} and {@code this % val} using the
//  * Burnikel-Ziegler algorithm.
//  * @param val the divisor
//  * @return an array containing the quotient and remainder
//  */
// private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {
//     MutableBigInteger q = new MutableBigInteger();
//     MutableBigInteger r = new MutableBigInteger(this).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);
//     BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(signum*val.signum);
//     BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(signum);
//     return new BigInteger[] {qBigInt, rBigInt};
// }

// /**
//  * Returns a BigInteger whose value is the greatest common divisor of
//  * {@code abs(this)} and {@code abs(val)}.  Returns 0 if
//  * {@code this == 0 && val == 0}.
//  *
//  * @param  val value with which the GCD is to be computed.
//  * @return {@code GCD(abs(this), abs(val))}
//  */
// public BigInteger gcd(BigInteger val) {
//     if (val.signum == 0)
//         return this.abs();
//     else if (this.signum == 0)
//         return val.abs();

//     MutableBigInteger a = new MutableBigInteger(this);
//     MutableBigInteger b = new MutableBigInteger(val);

//     MutableBigInteger result = a.hybridGCD(b);

//     return result.toBigInteger(1);
// }


// // Comparison Operations

// /**
//  * Compares this BigInteger with the specified BigInteger.  This
//  * method is provided in preference to individual methods for each
//  * of the six boolean comparison operators ({@literal <}, ==,
//  * {@literal >}, {@literal >=}, !=, {@literal <=}).  The suggested
//  * idiom for performing these comparisons is: {@code
//  * (x.compareTo(y)} &lt;<i>op</i>&gt; {@code 0)}, where
//  * &lt;<i>op</i>&gt; is one of the six comparison operators.
//  *
//  * @param  val BigInteger to which this BigInteger is to be compared.
//  * @return -1, 0 or 1 as this BigInteger is numerically less than, equal
//  *         to, or greater than {@code val}.
//  */
// public int compareTo(BigInteger val) {
//     if (signum == val.signum) {
//         switch (signum) {
//         case 1:
//             return compareMagnitude(val);
//         case -1:
//             return val.compareMagnitude(this);
//         default:
//             return 0;
//         }
//     }
//     return signum > val.signum ? 1 : -1;
// }

// /**
//  * Compares the magnitude array of this BigInteger with the specified
//  * BigInteger's. This is the version of compareTo ignoring sign.
//  *
//  * @param val BigInteger whose magnitude array to be compared.
//  * @return -1, 0 or 1 as this magnitude array is less than, equal to or
//  *         greater than the magnitude aray for the specified BigInteger's.
//  */
// final int compareMagnitude(BigInteger val) {
//     int[] m1 = mag;
//     int len1 = m1.length;
//     int[] m2 = val.mag;
//     int len2 = m2.length;
//     if (len1 < len2)
//         return -1;
//     if (len1 > len2)
//         return 1;
//     for (int i = 0; i < len1; i++) {
//         int a = m1[i];
//         int b = m2[i];
//         if (a != b)
//             return ((a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;
//     }
//     return 0;
// }

// /**
//  * Version of compareMagnitude that compares magnitude with long value.
//  * val can't be Long.MIN_VALUE.
//  */
// final int compareMagnitude(long val) {
//     assert val != Long.MIN_VALUE;
//     int[] m1 = mag;
//     int len = m1.length;
//     if (len > 2) {
//         return 1;
//     }
//     if (val < 0) {
//         val = -val;
//     }
//     int highWord = (int)(val >>> 32);
//     if (highWord == 0) {
//         if (len < 1)
//             return -1;
//         if (len > 1)
//             return 1;
//         int a = m1[0];
//         int b = (int)val;
//         if (a != b) {
//             return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
//         }
//         return 0;
//     } else {
//         if (len < 2)
//             return -1;
//         int a = m1[0];
//         int b = highWord;
//         if (a != b) {
//             return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
//         }
//         a = m1[1];
//         b = (int)val;
//         if (a != b) {
//             return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
//         }
//         return 0;
//     }
// }

// /**
//  * Compares this BigInteger with the specified Object for equality.
//  *
//  * @param  x Object to which this BigInteger is to be compared.
//  * @return {@code true} if and only if the specified Object is a
//  *         BigInteger whose value is numerically equal to this BigInteger.
//  */
// public boolean equals(Object x) {
//     // This test is just an optimization, which may or may not help
//     if (x == this)
//         return true;

//     if (!(x instanceof BigInteger))
//         return false;

//     BigInteger xInt = (BigInteger) x;
//     if (xInt.signum != signum)
//         return false;

//     int[] m = mag;
//     int len = m.length;
//     int[] xm = xInt.mag;
//     if (len != xm.length)
//         return false;

//     for (int i = 0; i < len; i++)
//         if (xm[i] != m[i])
//             return false;

//     return true;
// }

// /**
//  * Returns the minimum of this BigInteger and {@code val}.
//  *
//  * @param  val value with which the minimum is to be computed.
//  * @return the BigInteger whose value is the lesser of this BigInteger and
//  *         {@code val}.  If they are equal, either may be returned.
//  */
// public BigInteger min(BigInteger val) {
//     return (compareTo(val) < 0 ? this : val);
// }

// /**
//  * Returns the maximum of this BigInteger and {@code val}.
//  *
//  * @param  val value with which the maximum is to be computed.
//  * @return the BigInteger whose value is the greater of this and
//  *         {@code val}.  If they are equal, either may be returned.
//  */
// public BigInteger max(BigInteger val) {
//     return (compareTo(val) > 0 ? this : val);
// }


// // Hash Function

// /**
//  * Returns the hash code for this BigInteger.
//  *
//  * @return hash code for this BigInteger.
//  */
// public int hashCode() {
//     int hashCode = 0;

//     for (int i=0; i < mag.length; i++)
//         hashCode = (int)(31*hashCode + (mag[i] & LONG_MASK));

//     return hashCode * signum;
// }